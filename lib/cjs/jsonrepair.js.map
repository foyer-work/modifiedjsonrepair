{"version":3,"file":"jsonrepair.js","names":["controlCharacters","escapeCharacters","b","f","n","r","t","jsonrepair","text","i","output","processed","parseValue","throwUnexpectedEnd","processedComma","parseCharacter","codeComma","parseWhitespaceAndSkipComments","isStartOfValue","endsWithCommaOrNewline","insertBeforeLastWhitespace","parseNewlineDelimitedJSON","stripLastOccurrence","length","throwUnexpectedCharacter","parseObject","parseArray","parseString","parseNumber","parseKeywords","parseUnquotedString","start","changed","parseWhitespace","parseComment","whitespace","normal","isWhitespace","charCodeAt","isSpecialWhitespace","codeSlash","codeAsterisk","atEndOfBlockComment","codeNewline","code","skipCharacter","skipEscapeCharacter","codeBackslash","codeOpeningBrace","initial","codeClosingBrace","processedKey","codeClosingBracket","codeOpeningBracket","undefined","throwObjectKeyExpected","processedColon","codeColon","throwColonExpected","processedValue","throwObjectValueExpected","skipEscapeChars","isQuote","isEndQuote","isSingleQuote","isDoubleQuote","codeDoubleQuote","char","escapeChar","slice","isHex","throwInvalidUnicodeCharacter","isControlCharacter","isValidStringCharacter","throwInvalidCharacter","parseConcatenatedString","codePlus","removeAtIndex","codeMinus","expectDigit","codeZero","isNonZeroDigit","isDigit","codeDot","codeLowercaseE","codeUppercaseE","parseKeyword","name","value","isDelimiter","codeOpenParenthesis","codeCloseParenthesis","codeSemicolon","symbol","JSON","stringify","numSoFar","JSONRepairError","got","end","test","chars"],"sources":["../../src/jsonrepair.ts"],"sourcesContent":["import { JSONRepairError } from './JSONRepairError.js'\r\nimport {\r\n  codeAsterisk,\r\n  codeBackslash,\r\n  codeCloseParenthesis,\r\n  codeClosingBrace,\r\n  codeClosingBracket,\r\n  codeColon,\r\n  codeComma,\r\n  codeDot,\r\n  codeDoubleQuote,\r\n  codeLowercaseE,\r\n  codeMinus,\r\n  codeNewline,\r\n  codeOpeningBrace,\r\n  codeOpeningBracket,\r\n  codeOpenParenthesis,\r\n  codePlus,\r\n  codeSemicolon,\r\n  codeSlash,\r\n  codeUppercaseE,\r\n  codeZero,\r\n  endsWithCommaOrNewline,\r\n  insertBeforeLastWhitespace,\r\n  isControlCharacter,\r\n  isDelimiter,\r\n  isDigit,\r\n  isDoubleQuote,\r\n  isHex,\r\n  isNonZeroDigit,\r\n  isQuote,\r\n  isSingleQuote,\r\n  isSpecialWhitespace,\r\n  isStartOfValue,\r\n  isValidStringCharacter,\r\n  isWhitespace,\r\n  removeAtIndex,\r\n  stripLastOccurrence\r\n} from './stringUtils.js'\r\n\r\nconst controlCharacters: { [key: string]: string } = {\r\n  '\\b': '\\\\b',\r\n  '\\f': '\\\\f',\r\n  '\\n': '\\\\n',\r\n  '\\r': '\\\\r',\r\n  '\\t': '\\\\t'\r\n}\r\n\r\n// map with all escape characters\r\nconst escapeCharacters: { [key: string]: string } = {\r\n  '\"': '\"',\r\n  '\\\\': '\\\\',\r\n  '/': '/',\r\n  b: '\\b',\r\n  f: '\\f',\r\n  n: '\\n',\r\n  r: '\\r',\r\n  t: '\\t'\r\n  // note that \\u is handled separately in parseString()\r\n}\r\n\r\n/**\r\n * Repair a string containing an invalid JSON document.\r\n * For example changes JavaScript notation into JSON notation.\r\n *\r\n * Example:\r\n *\r\n *     try {\r\n *       const json = \"{name: 'John'}\"\r\n *       const repaired = jsonrepair(json)\r\n *       console.log(repaired)\r\n *       // '{\"name\": \"John\"}'\r\n *     } catch (err) {\r\n *       console.error(err)\r\n *     }\r\n *\r\n */\r\nexport function jsonrepair(text: string): string {\r\n  let i = 0 // current index in text\r\n  let output = '' // generated output\r\n\r\n  const processed = parseValue()\r\n  if (!processed) {\r\n    throwUnexpectedEnd()\r\n  }\r\n\r\n  const processedComma = parseCharacter(codeComma)\r\n  if (processedComma) {\r\n    parseWhitespaceAndSkipComments()\r\n  }\r\n\r\n  if (isStartOfValue(text[i]) && endsWithCommaOrNewline(output)) {\r\n    // start of a new value after end of the root level object: looks like\r\n    // newline delimited JSON -> turn into a root level array\r\n    if (!processedComma) {\r\n      // repair missing comma\r\n      output = insertBeforeLastWhitespace(output, ',')\r\n    }\r\n\r\n    parseNewlineDelimitedJSON()\r\n  } else if (processedComma) {\r\n    // repair: remove trailing comma\r\n    output = stripLastOccurrence(output, ',')\r\n  }\r\n\r\n  if (i >= text.length) {\r\n    // reached the end of the document properly\r\n    return output\r\n  }\r\n\r\n  throwUnexpectedCharacter()\r\n\r\n  function parseValue(): boolean {\r\n    parseWhitespaceAndSkipComments()\r\n    const processed =\r\n      parseObject() ||\r\n      parseArray() ||\r\n      parseString() ||\r\n      parseNumber() ||\r\n      parseKeywords() ||\r\n      parseUnquotedString()\r\n    parseWhitespaceAndSkipComments()\r\n\r\n    return processed\r\n  }\r\n\r\n  function parseWhitespaceAndSkipComments(): boolean {\r\n    const start = i\r\n\r\n    let changed = parseWhitespace()\r\n    do {\r\n      changed = parseComment()\r\n      if (changed) {\r\n        changed = parseWhitespace()\r\n      }\r\n    } while (changed)\r\n\r\n    return i > start\r\n  }\r\n\r\n  function parseWhitespace(): boolean {\r\n    let whitespace = ''\r\n    let normal: boolean\r\n    while ((normal = isWhitespace(text.charCodeAt(i))) || isSpecialWhitespace(text.charCodeAt(i))) {\r\n      if (normal) {\r\n        whitespace += text[i]\r\n      } else {\r\n        // repair special whitespace\r\n        whitespace += ' '\r\n      }\r\n\r\n      i++\r\n    }\r\n\r\n    if (whitespace.length > 0) {\r\n      output += whitespace\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function parseComment(): boolean {\r\n    // find a block comment '/* ... */'\r\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeAsterisk) {\r\n      // repair block comment by skipping it\r\n      while (i < text.length && !atEndOfBlockComment(text, i)) {\r\n        i++\r\n      }\r\n      i += 2\r\n\r\n      return true\r\n    }\r\n\r\n    // find a line comment '// ...'\r\n    if (text.charCodeAt(i) === codeSlash && text.charCodeAt(i + 1) === codeSlash) {\r\n      // repair line comment by skipping it\r\n      while (i < text.length && text.charCodeAt(i) !== codeNewline) {\r\n        i++\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function parseCharacter(code: number): boolean {\r\n    if (text.charCodeAt(i) === code) {\r\n      output += text[i]\r\n      i++\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function skipCharacter(code: number): boolean {\r\n    if (text.charCodeAt(i) === code) {\r\n      i++\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function skipEscapeCharacter(): boolean {\r\n    return skipCharacter(codeBackslash)\r\n  }\r\n\r\n  /**\r\n   * Parse an object like '{\"key\": \"value\"}'\r\n   */\r\n  function parseObject(): boolean {\r\n    if (text.charCodeAt(i) === codeOpeningBrace) {\r\n      output += '{'\r\n      i++\r\n      parseWhitespaceAndSkipComments()\r\n\r\n      let initial = true\r\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBrace) {\r\n        let processedComma\r\n        if (!initial) {\r\n          processedComma = parseCharacter(codeComma)\r\n          if (!processedComma) {\r\n            // repair missing comma\r\n            output = insertBeforeLastWhitespace(output, ',')\r\n          }\r\n          parseWhitespaceAndSkipComments()\r\n        } else {\r\n          processedComma = true\r\n          initial = false\r\n        }\r\n\r\n        const processedKey = parseString() || parseUnquotedString()\r\n        if (!processedKey) {\r\n          if (\r\n            text.charCodeAt(i) === codeClosingBrace ||\r\n            text.charCodeAt(i) === codeOpeningBrace ||\r\n            text.charCodeAt(i) === codeClosingBracket ||\r\n            text.charCodeAt(i) === codeOpeningBracket ||\r\n            text[i] === undefined\r\n          ) {\r\n            // repair trailing comma\r\n            output = stripLastOccurrence(output, ',')\r\n          } else {\r\n            throwObjectKeyExpected()\r\n          }\r\n          break\r\n        }\r\n\r\n        parseWhitespaceAndSkipComments()\r\n        const processedColon = parseCharacter(codeColon)\r\n        if (!processedColon) {\r\n          if (isStartOfValue(text[i])) {\r\n            // repair missing colon\r\n            output = insertBeforeLastWhitespace(output, ':')\r\n          } else {\r\n            throwColonExpected()\r\n          }\r\n        }\r\n        const processedValue = parseValue()\r\n        if (!processedValue) {\r\n          if (processedColon) {\r\n            throwObjectValueExpected()\r\n          } else {\r\n            throwColonExpected()\r\n          }\r\n        }\r\n      }\r\n\r\n      if (text.charCodeAt(i) === codeClosingBrace) {\r\n        output += '}'\r\n        i++\r\n      } else {\r\n        // repair missing end bracket\r\n        output = insertBeforeLastWhitespace(output, '}')\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Parse an array like '[\"item1\", \"item2\", ...]'\r\n   */\r\n  function parseArray(): boolean {\r\n    if (text.charCodeAt(i) === codeOpeningBracket) {\r\n      output += '['\r\n      i++\r\n      parseWhitespaceAndSkipComments()\r\n\r\n      let initial = true\r\n      while (i < text.length && text.charCodeAt(i) !== codeClosingBracket) {\r\n        if (!initial) {\r\n          const processedComma = parseCharacter(codeComma)\r\n          if (!processedComma) {\r\n            // repair missing comma\r\n            output = insertBeforeLastWhitespace(output, ',')\r\n          }\r\n        } else {\r\n          initial = false\r\n        }\r\n\r\n        const processedValue = parseValue()\r\n        if (!processedValue) {\r\n          // repair trailing comma\r\n          output = stripLastOccurrence(output, ',')\r\n          break\r\n        }\r\n      }\r\n\r\n      if (text.charCodeAt(i) === codeClosingBracket) {\r\n        output += ']'\r\n        i++\r\n      } else {\r\n        // repair missing closing array bracket\r\n        output = insertBeforeLastWhitespace(output, ']')\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Parse and repair Newline Delimited JSON (NDJSON):\r\n   * multiple JSON objects separated by a newline character\r\n   */\r\n  function parseNewlineDelimitedJSON() {\r\n    // repair NDJSON\r\n    let initial = true\r\n    let processedValue = true\r\n    while (processedValue) {\r\n      if (!initial) {\r\n        // parse optional comma, insert when missing\r\n        const processedComma = parseCharacter(codeComma)\r\n        if (!processedComma) {\r\n          // repair: add missing comma\r\n          output = insertBeforeLastWhitespace(output, ',')\r\n        }\r\n      } else {\r\n        initial = false\r\n      }\r\n\r\n      processedValue = parseValue()\r\n    }\r\n\r\n    if (!processedValue) {\r\n      // repair: remove trailing comma\r\n      output = stripLastOccurrence(output, ',')\r\n    }\r\n\r\n    // repair: wrap the output inside array brackets\r\n    output = `[\\n${output}\\n]`\r\n  }\r\n\r\n  /**\r\n   * Parse a string enclosed by double quotes \"...\". Can contain escaped quotes\r\n   * Repair strings enclosed in single quotes or special quotes\r\n   * Repair an escaped string\r\n   */\r\n  function parseString(): boolean {\r\n    let skipEscapeChars = text.charCodeAt(i) === codeBackslash\r\n    if (skipEscapeChars) {\r\n      // repair: remove the first escape character\r\n      i++\r\n      skipEscapeChars = true\r\n    }\r\n\r\n    if (isQuote(text.charCodeAt(i))) {\r\n      const isEndQuote = isSingleQuote(text.charCodeAt(i)) ? isSingleQuote : isDoubleQuote\r\n\r\n      if (text.charCodeAt(i) !== codeDoubleQuote) {\r\n        // repair non-normalized quote\r\n      }\r\n      output += '\"'\r\n      i++\r\n\r\n      while (i < text.length && !isEndQuote(text.charCodeAt(i))) {\r\n        if (text.charCodeAt(i) === codeBackslash) {\r\n          const char = text[i + 1]\r\n          const escapeChar = escapeCharacters[char]\r\n          if (escapeChar !== undefined) {\r\n            output += text.slice(i, i + 2)\r\n            i += 2\r\n          } else if (char === 'u') {\r\n            if (\r\n              isHex(text.charCodeAt(i + 2)) &&\r\n              isHex(text.charCodeAt(i + 3)) &&\r\n              isHex(text.charCodeAt(i + 4)) &&\r\n              isHex(text.charCodeAt(i + 5))\r\n            ) {\r\n              output += text.slice(i, i + 6)\r\n              i += 6\r\n            } else {\r\n              throwInvalidUnicodeCharacter(i)\r\n            }\r\n          } else {\r\n            // repair invalid escape character: remove it\r\n            output += char\r\n            i += 2\r\n          }\r\n        } else {\r\n          const char = text[i]\r\n          const code = text.charCodeAt(i)\r\n\r\n          if (code === codeDoubleQuote && text.charCodeAt(i - 1) !== codeBackslash) {\r\n            // repair unescaped double quote\r\n            output += '\\\\' + char\r\n            i++\r\n          } else if (isControlCharacter(code)) {\r\n            // unescaped control character\r\n            output += controlCharacters[char]\r\n            i++\r\n          } else {\r\n            if (!isValidStringCharacter(code)) {\r\n              throwInvalidCharacter(char)\r\n            }\r\n            output += char\r\n            i++\r\n          }\r\n        }\r\n\r\n        if (skipEscapeChars) {\r\n          const processed = skipEscapeCharacter()\r\n          if (processed) {\r\n            // repair: skipped escape character (nothing to do)\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isQuote(text.charCodeAt(i))) {\r\n        if (text.charCodeAt(i) !== codeDoubleQuote) {\r\n          // repair non-normalized quote\r\n        }\r\n        output += '\"'\r\n        i++\r\n      } else {\r\n        // repair missing end quote\r\n        output += '\"'\r\n      }\r\n\r\n      parseConcatenatedString()\r\n\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Repair concatenated strings like \"hello\" + \"world\", change this into \"helloworld\"\r\n   */\r\n  function parseConcatenatedString(): boolean {\r\n    let processed = false\r\n\r\n    parseWhitespaceAndSkipComments()\r\n    while (text.charCodeAt(i) === codePlus) {\r\n      processed = true\r\n      i++\r\n      parseWhitespaceAndSkipComments()\r\n\r\n      // repair: remove the end quote of the first string\r\n      output = stripLastOccurrence(output, '\"', true)\r\n      const start = output.length\r\n      parseString()\r\n\r\n      // repair: remove the start quote of the second string\r\n      output = removeAtIndex(output, start, 1)\r\n    }\r\n\r\n    return processed\r\n  }\r\n\r\n  /**\r\n   * Parse a number like 2.4 or 2.4e6\r\n   */\r\n  function parseNumber(): boolean {\r\n    const start = i\r\n    if (text.charCodeAt(i) === codeMinus) {\r\n      i++\r\n      expectDigit(start)\r\n    }\r\n\r\n    if (text.charCodeAt(i) === codeZero) {\r\n      i++\r\n    } else if (isNonZeroDigit(text.charCodeAt(i))) {\r\n      i++\r\n      while (isDigit(text.charCodeAt(i))) {\r\n        i++\r\n      }\r\n    }\r\n\r\n    if (text.charCodeAt(i) === codeDot) {\r\n      i++\r\n      expectDigit(start)\r\n      while (isDigit(text.charCodeAt(i))) {\r\n        i++\r\n      }\r\n    }\r\n\r\n    if (text.charCodeAt(i) === codeLowercaseE || text.charCodeAt(i) === codeUppercaseE) {\r\n      i++\r\n      if (text.charCodeAt(i) === codeMinus || text.charCodeAt(i) === codePlus) {\r\n        i++\r\n      }\r\n      expectDigit(start)\r\n      while (isDigit(text.charCodeAt(i))) {\r\n        i++\r\n      }\r\n    }\r\n\r\n    if (i > start) {\r\n      output += text.slice(start, i)\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Parse keywords true, false, null\r\n   * Repair Python keywords True, False, None\r\n   */\r\n  function parseKeywords(): boolean {\r\n    return (\r\n      parseKeyword('true', 'true') ||\r\n      parseKeyword('false', 'false') ||\r\n      parseKeyword('null', 'null') ||\r\n      // repair Python keywords True, False, None\r\n      parseKeyword('True', 'true') ||\r\n      parseKeyword('False', 'false') ||\r\n      parseKeyword('None', 'null')\r\n    )\r\n  }\r\n\r\n  function parseKeyword(name: string, value: string): boolean {\r\n    if (text.slice(i, i + name.length) === name) {\r\n      output += value\r\n      i += name.length\r\n      return true\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * Repair and unquoted string by adding quotes around it\r\n   * Repair a MongoDB function call like NumberLong(\"2\")\r\n   * Repair a JSONP function call like callback({...});\r\n   */\r\n  function parseUnquotedString() {\r\n    // note that the symbol can end with whitespaces: we stop at the next delimiter\r\n    const start = i\r\n    while (i < text.length && !isDelimiter(text[i])) {\r\n      i++\r\n    }\r\n\r\n    if (i > start) {\r\n      if (text.charCodeAt(i) === codeOpenParenthesis) {\r\n        // repair a MongoDB function call like NumberLong(\"2\")\r\n        // repair a JSONP function call like callback({...});\r\n        i++\r\n\r\n        parseValue()\r\n\r\n        if (text.charCodeAt(i) === codeCloseParenthesis) {\r\n          // repair: skip close bracket of function call\r\n          i++\r\n          if (text.charCodeAt(i) === codeSemicolon) {\r\n            // repair: skip semicolon after JSONP call\r\n            i++\r\n          }\r\n        }\r\n\r\n        return true\r\n      } else {\r\n        // repair unquoted string\r\n\r\n        // first, go back to prevent getting trailing whitespaces in the string\r\n        while (isWhitespace(text.charCodeAt(i - 1)) && i > 0) {\r\n          i--\r\n        }\r\n\r\n        const symbol = text.slice(start, i)\r\n        output += JSON.stringify(symbol)\r\n\r\n        return true\r\n      }\r\n    }\r\n  }\r\n\r\n  function expectDigit(start: number) {\r\n    if (!isDigit(text.charCodeAt(i))) {\r\n      const numSoFar = text.slice(start, i)\r\n      throw new JSONRepairError(`Invalid number '${numSoFar}', expecting a digit ${got()}`, 2)\r\n    }\r\n  }\r\n\r\n  function throwInvalidCharacter(char: string) {\r\n    throw new JSONRepairError('Invalid character ' + JSON.stringify(char), i)\r\n  }\r\n\r\n  function throwUnexpectedCharacter() {\r\n    throw new JSONRepairError('Unexpected character ' + JSON.stringify(text[i]), i)\r\n  }\r\n\r\n  function throwUnexpectedEnd() {\r\n    throw new JSONRepairError('Unexpected end of json string', text.length)\r\n  }\r\n\r\n  function throwObjectKeyExpected() {\r\n    throw new JSONRepairError('Object key expected', i)\r\n  }\r\n\r\n  function throwObjectValueExpected() {\r\n    throw new JSONRepairError('Object value expected', i)\r\n  }\r\n\r\n  function throwColonExpected() {\r\n    throw new JSONRepairError('Colon expected', i)\r\n  }\r\n\r\n  function throwInvalidUnicodeCharacter(start: number) {\r\n    let end = start + 2\r\n    while (/\\w/.test(text[end])) {\r\n      end++\r\n    }\r\n    const chars = text.slice(start, end)\r\n    throw new JSONRepairError(`Invalid unicode character \"${chars}\"`, i)\r\n  }\r\n\r\n  function got(): string {\r\n    return text[i] ? `but got '${text[i]}'` : 'but reached end of input'\r\n  }\r\n}\r\n\r\nfunction atEndOfBlockComment(text: string, i: number) {\r\n  return text[i] === '*' && text[i + 1] === '/'\r\n}\r\n"],"mappings":";;;;;;AAAA;AACA;AAuCA,IAAMA,iBAA4C,GAAG;EACnD,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE,KAAK;EACX,IAAI,EAAE;AACR,CAAC;;AAED;AACA,IAAMC,gBAA2C,GAAG;EAClD,GAAG,EAAE,GAAG;EACR,IAAI,EAAE,IAAI;EACV,GAAG,EAAE,GAAG;EACRC,CAAC,EAAE,IAAI;EACPC,CAAC,EAAE,IAAI;EACPC,CAAC,EAAE,IAAI;EACPC,CAAC,EAAE,IAAI;EACPC,CAAC,EAAE;EACH;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,UAAU,CAACC,IAAY,EAAU;EAC/C,IAAIC,CAAC,GAAG,CAAC,EAAC;EACV,IAAIC,MAAM,GAAG,EAAE,EAAC;;EAEhB,IAAMC,SAAS,GAAGC,UAAU,EAAE;EAC9B,IAAI,CAACD,SAAS,EAAE;IACdE,kBAAkB,EAAE;EACtB;EAEA,IAAMC,cAAc,GAAGC,cAAc,CAACC,sBAAS,CAAC;EAChD,IAAIF,cAAc,EAAE;IAClBG,8BAA8B,EAAE;EAClC;EAEA,IAAI,IAAAC,2BAAc,EAACV,IAAI,CAACC,CAAC,CAAC,CAAC,IAAI,IAAAU,mCAAsB,EAACT,MAAM,CAAC,EAAE;IAC7D;IACA;IACA,IAAI,CAACI,cAAc,EAAE;MACnB;MACAJ,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;IAClD;IAEAW,yBAAyB,EAAE;EAC7B,CAAC,MAAM,IAAIP,cAAc,EAAE;IACzB;IACAJ,MAAM,GAAG,IAAAY,gCAAmB,EAACZ,MAAM,EAAE,GAAG,CAAC;EAC3C;EAEA,IAAID,CAAC,IAAID,IAAI,CAACe,MAAM,EAAE;IACpB;IACA,OAAOb,MAAM;EACf;EAEAc,wBAAwB,EAAE;EAE1B,SAASZ,UAAU,GAAY;IAC7BK,8BAA8B,EAAE;IAChC,IAAMN,SAAS,GACbc,WAAW,EAAE,IACbC,UAAU,EAAE,IACZC,WAAW,EAAE,IACbC,WAAW,EAAE,IACbC,aAAa,EAAE,IACfC,mBAAmB,EAAE;IACvBb,8BAA8B,EAAE;IAEhC,OAAON,SAAS;EAClB;EAEA,SAASM,8BAA8B,GAAY;IACjD,IAAMc,KAAK,GAAGtB,CAAC;IAEf,IAAIuB,OAAO,GAAGC,eAAe,EAAE;IAC/B,GAAG;MACDD,OAAO,GAAGE,YAAY,EAAE;MACxB,IAAIF,OAAO,EAAE;QACXA,OAAO,GAAGC,eAAe,EAAE;MAC7B;IACF,CAAC,QAAQD,OAAO;IAEhB,OAAOvB,CAAC,GAAGsB,KAAK;EAClB;EAEA,SAASE,eAAe,GAAY;IAClC,IAAIE,UAAU,GAAG,EAAE;IACnB,IAAIC,MAAe;IACnB,OAAO,CAACA,MAAM,GAAG,IAAAC,yBAAY,EAAC7B,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,KAAK,IAAA8B,gCAAmB,EAAC/B,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;MAC7F,IAAI2B,MAAM,EAAE;QACVD,UAAU,IAAI3B,IAAI,CAACC,CAAC,CAAC;MACvB,CAAC,MAAM;QACL;QACA0B,UAAU,IAAI,GAAG;MACnB;MAEA1B,CAAC,EAAE;IACL;IAEA,IAAI0B,UAAU,CAACZ,MAAM,GAAG,CAAC,EAAE;MACzBb,MAAM,IAAIyB,UAAU;MACpB,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA,SAASD,YAAY,GAAY;IAC/B;IACA,IAAI1B,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK+B,sBAAS,IAAIhC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,KAAKgC,yBAAY,EAAE;MAC/E;MACA,OAAOhC,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAI,CAACmB,mBAAmB,CAAClC,IAAI,EAAEC,CAAC,CAAC,EAAE;QACvDA,CAAC,EAAE;MACL;MACAA,CAAC,IAAI,CAAC;MAEN,OAAO,IAAI;IACb;;IAEA;IACA,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK+B,sBAAS,IAAIhC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,KAAK+B,sBAAS,EAAE;MAC5E;MACA,OAAO/B,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAIf,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKkC,wBAAW,EAAE;QAC5DlC,CAAC,EAAE;MACL;MAEA,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA,SAASM,cAAc,CAAC6B,IAAY,EAAW;IAC7C,IAAIpC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKmC,IAAI,EAAE;MAC/BlC,MAAM,IAAIF,IAAI,CAACC,CAAC,CAAC;MACjBA,CAAC,EAAE;MACH,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA,SAASoC,aAAa,CAACD,IAAY,EAAW;IAC5C,IAAIpC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKmC,IAAI,EAAE;MAC/BnC,CAAC,EAAE;MACH,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;EAEA,SAASqC,mBAAmB,GAAY;IACtC,OAAOD,aAAa,CAACE,0BAAa,CAAC;EACrC;;EAEA;AACF;AACA;EACE,SAAStB,WAAW,GAAY;IAC9B,IAAIjB,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKuC,6BAAgB,EAAE;MAC3CtC,MAAM,IAAI,GAAG;MACbD,CAAC,EAAE;MACHQ,8BAA8B,EAAE;MAEhC,IAAIgC,OAAO,GAAG,IAAI;MAClB,OAAOxC,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAIf,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKyC,6BAAgB,EAAE;QACjE,IAAIpC,eAAc;QAClB,IAAI,CAACmC,OAAO,EAAE;UACZnC,eAAc,GAAGC,cAAc,CAACC,sBAAS,CAAC;UAC1C,IAAI,CAACF,eAAc,EAAE;YACnB;YACAJ,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;UAClD;UACAO,8BAA8B,EAAE;QAClC,CAAC,MAAM;UACLH,eAAc,GAAG,IAAI;UACrBmC,OAAO,GAAG,KAAK;QACjB;QAEA,IAAME,YAAY,GAAGxB,WAAW,EAAE,IAAIG,mBAAmB,EAAE;QAC3D,IAAI,CAACqB,YAAY,EAAE;UACjB,IACE3C,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKyC,6BAAgB,IACvC1C,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKuC,6BAAgB,IACvCxC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK2C,+BAAkB,IACzC5C,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK4C,+BAAkB,IACzC7C,IAAI,CAACC,CAAC,CAAC,KAAK6C,SAAS,EACrB;YACA;YACA5C,MAAM,GAAG,IAAAY,gCAAmB,EAACZ,MAAM,EAAE,GAAG,CAAC;UAC3C,CAAC,MAAM;YACL6C,sBAAsB,EAAE;UAC1B;UACA;QACF;QAEAtC,8BAA8B,EAAE;QAChC,IAAMuC,cAAc,GAAGzC,cAAc,CAAC0C,sBAAS,CAAC;QAChD,IAAI,CAACD,cAAc,EAAE;UACnB,IAAI,IAAAtC,2BAAc,EAACV,IAAI,CAACC,CAAC,CAAC,CAAC,EAAE;YAC3B;YACAC,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;UAClD,CAAC,MAAM;YACLgD,kBAAkB,EAAE;UACtB;QACF;QACA,IAAMC,cAAc,GAAG/C,UAAU,EAAE;QACnC,IAAI,CAAC+C,cAAc,EAAE;UACnB,IAAIH,cAAc,EAAE;YAClBI,wBAAwB,EAAE;UAC5B,CAAC,MAAM;YACLF,kBAAkB,EAAE;UACtB;QACF;MACF;MAEA,IAAIlD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKyC,6BAAgB,EAAE;QAC3CxC,MAAM,IAAI,GAAG;QACbD,CAAC,EAAE;MACL,CAAC,MAAM;QACL;QACAC,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;MAClD;MAEA,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;EACE,SAASgB,UAAU,GAAY;IAC7B,IAAIlB,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK4C,+BAAkB,EAAE;MAC7C3C,MAAM,IAAI,GAAG;MACbD,CAAC,EAAE;MACHQ,8BAA8B,EAAE;MAEhC,IAAIgC,OAAO,GAAG,IAAI;MAClB,OAAOxC,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAIf,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK2C,+BAAkB,EAAE;QACnE,IAAI,CAACH,OAAO,EAAE;UACZ,IAAMnC,gBAAc,GAAGC,cAAc,CAACC,sBAAS,CAAC;UAChD,IAAI,CAACF,gBAAc,EAAE;YACnB;YACAJ,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;UAClD;QACF,CAAC,MAAM;UACLuC,OAAO,GAAG,KAAK;QACjB;QAEA,IAAMU,cAAc,GAAG/C,UAAU,EAAE;QACnC,IAAI,CAAC+C,cAAc,EAAE;UACnB;UACAjD,MAAM,GAAG,IAAAY,gCAAmB,EAACZ,MAAM,EAAE,GAAG,CAAC;UACzC;QACF;MACF;MAEA,IAAIF,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK2C,+BAAkB,EAAE;QAC7C1C,MAAM,IAAI,GAAG;QACbD,CAAC,EAAE;MACL,CAAC,MAAM;QACL;QACAC,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;MAClD;MAEA,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;EACE,SAASW,yBAAyB,GAAG;IACnC;IACA,IAAI4B,OAAO,GAAG,IAAI;IAClB,IAAIU,cAAc,GAAG,IAAI;IACzB,OAAOA,cAAc,EAAE;MACrB,IAAI,CAACV,OAAO,EAAE;QACZ;QACA,IAAMnC,gBAAc,GAAGC,cAAc,CAACC,sBAAS,CAAC;QAChD,IAAI,CAACF,gBAAc,EAAE;UACnB;UACAJ,MAAM,GAAG,IAAAU,uCAA0B,EAACV,MAAM,EAAE,GAAG,CAAC;QAClD;MACF,CAAC,MAAM;QACLuC,OAAO,GAAG,KAAK;MACjB;MAEAU,cAAc,GAAG/C,UAAU,EAAE;IAC/B;IAEA,IAAI,CAAC+C,cAAc,EAAE;MACnB;MACAjD,MAAM,GAAG,IAAAY,gCAAmB,EAACZ,MAAM,EAAE,GAAG,CAAC;IAC3C;;IAEA;IACAA,MAAM,gBAASA,MAAM,QAAK;EAC5B;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASiB,WAAW,GAAY;IAC9B,IAAIkC,eAAe,GAAGrD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKsC,0BAAa;IAC1D,IAAIc,eAAe,EAAE;MACnB;MACApD,CAAC,EAAE;MACHoD,eAAe,GAAG,IAAI;IACxB;IAEA,IAAI,IAAAC,oBAAO,EAACtD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;MAC/B,IAAMsD,UAAU,GAAG,IAAAC,0BAAa,EAACxD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,GAAGuD,0BAAa,GAAGC,0BAAa;MAEpF,IAAIzD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKyD,4BAAe,EAAE;QAC1C;MAAA;MAEFxD,MAAM,IAAI,GAAG;MACbD,CAAC,EAAE;MAEH,OAAOA,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAI,CAACwC,UAAU,CAACvD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;QACzD,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKsC,0BAAa,EAAE;UACxC,IAAMoB,IAAI,GAAG3D,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC;UACxB,IAAM2D,UAAU,GAAGnE,gBAAgB,CAACkE,IAAI,CAAC;UACzC,IAAIC,UAAU,KAAKd,SAAS,EAAE;YAC5B5C,MAAM,IAAIF,IAAI,CAAC6D,KAAK,CAAC5D,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;YAC9BA,CAAC,IAAI,CAAC;UACR,CAAC,MAAM,IAAI0D,IAAI,KAAK,GAAG,EAAE;YACvB,IACE,IAAAG,kBAAK,EAAC9D,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,CAAC,IAC7B,IAAA6D,kBAAK,EAAC9D,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,CAAC,IAC7B,IAAA6D,kBAAK,EAAC9D,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,CAAC,IAC7B,IAAA6D,kBAAK,EAAC9D,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,CAAC,EAC7B;cACAC,MAAM,IAAIF,IAAI,CAAC6D,KAAK,CAAC5D,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;cAC9BA,CAAC,IAAI,CAAC;YACR,CAAC,MAAM;cACL8D,4BAA4B,CAAC9D,CAAC,CAAC;YACjC;UACF,CAAC,MAAM;YACL;YACAC,MAAM,IAAIyD,IAAI;YACd1D,CAAC,IAAI,CAAC;UACR;QACF,CAAC,MAAM;UACL,IAAM0D,KAAI,GAAG3D,IAAI,CAACC,CAAC,CAAC;UACpB,IAAMmC,IAAI,GAAGpC,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC;UAE/B,IAAImC,IAAI,KAAKsB,4BAAe,IAAI1D,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,KAAKsC,0BAAa,EAAE;YACxE;YACArC,MAAM,IAAI,IAAI,GAAGyD,KAAI;YACrB1D,CAAC,EAAE;UACL,CAAC,MAAM,IAAI,IAAA+D,+BAAkB,EAAC5B,IAAI,CAAC,EAAE;YACnC;YACAlC,MAAM,IAAIV,iBAAiB,CAACmE,KAAI,CAAC;YACjC1D,CAAC,EAAE;UACL,CAAC,MAAM;YACL,IAAI,CAAC,IAAAgE,mCAAsB,EAAC7B,IAAI,CAAC,EAAE;cACjC8B,qBAAqB,CAACP,KAAI,CAAC;YAC7B;YACAzD,MAAM,IAAIyD,KAAI;YACd1D,CAAC,EAAE;UACL;QACF;QAEA,IAAIoD,eAAe,EAAE;UACnB,IAAMlD,UAAS,GAAGmC,mBAAmB,EAAE;UACvC,IAAInC,UAAS,EAAE;YACb;UAAA;QAEJ;MACF;MAEA,IAAI,IAAAmD,oBAAO,EAACtD,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;QAC/B,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKyD,4BAAe,EAAE;UAC1C;QAAA;QAEFxD,MAAM,IAAI,GAAG;QACbD,CAAC,EAAE;MACL,CAAC,MAAM;QACL;QACAC,MAAM,IAAI,GAAG;MACf;MAEAiE,uBAAuB,EAAE;MAEzB,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;EACE,SAASA,uBAAuB,GAAY;IAC1C,IAAIhE,SAAS,GAAG,KAAK;IAErBM,8BAA8B,EAAE;IAChC,OAAOT,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKmE,qBAAQ,EAAE;MACtCjE,SAAS,GAAG,IAAI;MAChBF,CAAC,EAAE;MACHQ,8BAA8B,EAAE;;MAEhC;MACAP,MAAM,GAAG,IAAAY,gCAAmB,EAACZ,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC;MAC/C,IAAMqB,KAAK,GAAGrB,MAAM,CAACa,MAAM;MAC3BI,WAAW,EAAE;;MAEb;MACAjB,MAAM,GAAG,IAAAmE,0BAAa,EAACnE,MAAM,EAAEqB,KAAK,EAAE,CAAC,CAAC;IAC1C;IAEA,OAAOpB,SAAS;EAClB;;EAEA;AACF;AACA;EACE,SAASiB,WAAW,GAAY;IAC9B,IAAMG,KAAK,GAAGtB,CAAC;IACf,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKqE,sBAAS,EAAE;MACpCrE,CAAC,EAAE;MACHsE,WAAW,CAAChD,KAAK,CAAC;IACpB;IAEA,IAAIvB,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKuE,qBAAQ,EAAE;MACnCvE,CAAC,EAAE;IACL,CAAC,MAAM,IAAI,IAAAwE,2BAAc,EAACzE,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;MAC7CA,CAAC,EAAE;MACH,OAAO,IAAAyE,oBAAO,EAAC1E,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;QAClCA,CAAC,EAAE;MACL;IACF;IAEA,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK0E,oBAAO,EAAE;MAClC1E,CAAC,EAAE;MACHsE,WAAW,CAAChD,KAAK,CAAC;MAClB,OAAO,IAAAmD,oBAAO,EAAC1E,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;QAClCA,CAAC,EAAE;MACL;IACF;IAEA,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK2E,2BAAc,IAAI5E,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAK4E,2BAAc,EAAE;MAClF5E,CAAC,EAAE;MACH,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKqE,sBAAS,IAAItE,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKmE,qBAAQ,EAAE;QACvEnE,CAAC,EAAE;MACL;MACAsE,WAAW,CAAChD,KAAK,CAAC;MAClB,OAAO,IAAAmD,oBAAO,EAAC1E,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;QAClCA,CAAC,EAAE;MACL;IACF;IAEA,IAAIA,CAAC,GAAGsB,KAAK,EAAE;MACbrB,MAAM,IAAIF,IAAI,CAAC6D,KAAK,CAACtC,KAAK,EAAEtB,CAAC,CAAC;MAC9B,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;EACE,SAASoB,aAAa,GAAY;IAChC,OACEyD,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,IAC5BA,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,IAC9BA,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;IAC5B;IACAA,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC,IAC5BA,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,IAC9BA,YAAY,CAAC,MAAM,EAAE,MAAM,CAAC;EAEhC;EAEA,SAASA,YAAY,CAACC,IAAY,EAAEC,KAAa,EAAW;IAC1D,IAAIhF,IAAI,CAAC6D,KAAK,CAAC5D,CAAC,EAAEA,CAAC,GAAG8E,IAAI,CAAChE,MAAM,CAAC,KAAKgE,IAAI,EAAE;MAC3C7E,MAAM,IAAI8E,KAAK;MACf/E,CAAC,IAAI8E,IAAI,CAAChE,MAAM;MAChB,OAAO,IAAI;IACb;IAEA,OAAO,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACE,SAASO,mBAAmB,GAAG;IAC7B;IACA,IAAMC,KAAK,GAAGtB,CAAC;IACf,OAAOA,CAAC,GAAGD,IAAI,CAACe,MAAM,IAAI,CAAC,IAAAkE,wBAAW,EAACjF,IAAI,CAACC,CAAC,CAAC,CAAC,EAAE;MAC/CA,CAAC,EAAE;IACL;IAEA,IAAIA,CAAC,GAAGsB,KAAK,EAAE;MACb,IAAIvB,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKiF,gCAAmB,EAAE;QAC9C;QACA;QACAjF,CAAC,EAAE;QAEHG,UAAU,EAAE;QAEZ,IAAIJ,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKkF,iCAAoB,EAAE;UAC/C;UACAlF,CAAC,EAAE;UACH,IAAID,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,KAAKmF,0BAAa,EAAE;YACxC;YACAnF,CAAC,EAAE;UACL;QACF;QAEA,OAAO,IAAI;MACb,CAAC,MAAM;QACL;;QAEA;QACA,OAAO,IAAA4B,yBAAY,EAAC7B,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,GAAG,CAAC,CAAC,CAAC,IAAIA,CAAC,GAAG,CAAC,EAAE;UACpDA,CAAC,EAAE;QACL;QAEA,IAAMoF,MAAM,GAAGrF,IAAI,CAAC6D,KAAK,CAACtC,KAAK,EAAEtB,CAAC,CAAC;QACnCC,MAAM,IAAIoF,IAAI,CAACC,SAAS,CAACF,MAAM,CAAC;QAEhC,OAAO,IAAI;MACb;IACF;EACF;EAEA,SAASd,WAAW,CAAChD,KAAa,EAAE;IAClC,IAAI,CAAC,IAAAmD,oBAAO,EAAC1E,IAAI,CAAC8B,UAAU,CAAC7B,CAAC,CAAC,CAAC,EAAE;MAChC,IAAMuF,QAAQ,GAAGxF,IAAI,CAAC6D,KAAK,CAACtC,KAAK,EAAEtB,CAAC,CAAC;MACrC,MAAM,IAAIwF,gCAAe,2BAAoBD,QAAQ,kCAAwBE,GAAG,EAAE,GAAI,CAAC,CAAC;IAC1F;EACF;EAEA,SAASxB,qBAAqB,CAACP,IAAY,EAAE;IAC3C,MAAM,IAAI8B,gCAAe,CAAC,oBAAoB,GAAGH,IAAI,CAACC,SAAS,CAAC5B,IAAI,CAAC,EAAE1D,CAAC,CAAC;EAC3E;EAEA,SAASe,wBAAwB,GAAG;IAClC,MAAM,IAAIyE,gCAAe,CAAC,uBAAuB,GAAGH,IAAI,CAACC,SAAS,CAACvF,IAAI,CAACC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC;EACjF;EAEA,SAASI,kBAAkB,GAAG;IAC5B,MAAM,IAAIoF,gCAAe,CAAC,+BAA+B,EAAEzF,IAAI,CAACe,MAAM,CAAC;EACzE;EAEA,SAASgC,sBAAsB,GAAG;IAChC,MAAM,IAAI0C,gCAAe,CAAC,qBAAqB,EAAExF,CAAC,CAAC;EACrD;EAEA,SAASmD,wBAAwB,GAAG;IAClC,MAAM,IAAIqC,gCAAe,CAAC,uBAAuB,EAAExF,CAAC,CAAC;EACvD;EAEA,SAASiD,kBAAkB,GAAG;IAC5B,MAAM,IAAIuC,gCAAe,CAAC,gBAAgB,EAAExF,CAAC,CAAC;EAChD;EAEA,SAAS8D,4BAA4B,CAACxC,KAAa,EAAE;IACnD,IAAIoE,GAAG,GAAGpE,KAAK,GAAG,CAAC;IACnB,OAAO,IAAI,CAACqE,IAAI,CAAC5F,IAAI,CAAC2F,GAAG,CAAC,CAAC,EAAE;MAC3BA,GAAG,EAAE;IACP;IACA,IAAME,KAAK,GAAG7F,IAAI,CAAC6D,KAAK,CAACtC,KAAK,EAAEoE,GAAG,CAAC;IACpC,MAAM,IAAIF,gCAAe,uCAA+BI,KAAK,SAAK5F,CAAC,CAAC;EACtE;EAEA,SAASyF,GAAG,GAAW;IACrB,OAAO1F,IAAI,CAACC,CAAC,CAAC,sBAAeD,IAAI,CAACC,CAAC,CAAC,SAAM,0BAA0B;EACtE;AACF;AAEA,SAASiC,mBAAmB,CAAClC,IAAY,EAAEC,CAAS,EAAE;EACpD,OAAOD,IAAI,CAACC,CAAC,CAAC,KAAK,GAAG,IAAID,IAAI,CAACC,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG;AAC/C"}